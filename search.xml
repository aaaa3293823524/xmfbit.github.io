<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CS131-描述图像的特征(SIFT)]]></title>
      <url>%2F2017%2F01%2F30%2Fcs131-sift%2F</url>
      <content type="text"><![CDATA[SIFT介绍上讲中介绍的Harris角点方法计算渐变]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CS131-描述图像的特征(Harris 角点)]]></title>
      <url>%2F2017%2F01%2F25%2Fcs131-finding-features%2F</url>
      <content type="text"><![CDATA[局部不变特征feature是对图像的描述。比如，图像整体灰度值的均值和方差就可以作为feature。如果我们想在一副图像中检测足球时，可以使用滑动窗方法，逐一检查窗口内的灰度值分布是否和一张给定的典型黑白格子足球相似。可想而知，这种方法的性能一定让人捉急。而在image matching问题中，常常需要将不同视角的同一目标物进行matching，进而计算相机转过的角度。这在SLAM问题中很有意义。如下图所示，同一处景观，在不同摄影师的镜头下，不仅视角不同，而且明暗变化也有很多差别，右侧的图暖色调更浓。这也告诉我们，上面提到的只使用全局图像灰度值来做feature的做法有多么不靠谱。 首先，让我们脱离全局特征，转而将注意力集中在局部特征上。这是因为使用局部特征能够更好地处理图像中的遮挡、变形等情况，而且我们的研究对象常常是图像中的部分区域而不是图像整体。更特殊地，在这一讲中，我们主要探究key point作为local feature的描述。 Harris角点角点，即corner，和edge类似，区别在于其在两个方向上都有较为剧烈的灰度变化（而edge只在某一个方向上灰度值变化剧烈）。如图所示。 Harris角点得名于其发明者Harris，是一种常见的角点检测方法。给定观察窗口大小，计算平移后窗口内各个像素差值的加权平方和，如下式。 E(u,v) = \sum_x\sum_yw(x,y)[I(x+u, y+v) - I(x,y)]^2其中，窗口加权函数$w$可以取做门限函数或gaussian函数。如图所示。 使用泰勒级数展开，并忽略非线性项，我们有 I(x+u,y+v) = I(x,y) + I_x(x,y)u+I_y(x,y)v所以上式可以写成（线性二次型写成了矩阵形式）， E(u,v) = \sum_{x,y}w(I_xu+I_yv)^2 = \begin{bmatrix}u&v\end{bmatrix}M\begin{bmatrix}u\\\\v\end{bmatrix}其中， M = w\begin{bmatrix}I_x^2& I_xI_y\\\\I_xI_y&I_y^2\end{bmatrix}当使用门限函数时，权值$w_{i,j} = 1$，则， M = \begin{bmatrix}\sum I_xI_x& \sum I_xI_y\\\\\sum I_xI_y&\sum I_yI_y\end{bmatrix} = \sum \begin{bmatrix}I_x \\\\I_y\end{bmatrix}\begin{bmatrix}I_x &I_y\end{bmatrix}当corner与xy坐标轴对齐时候，如下图所示。由于在黑色观察窗口内，只有上侧和左侧存在边缘，且在上边缘，$I_y$很大，而$I_x=0$，在左侧边缘，$I_x$很大而$I_y = 0$，所以，矩阵 M = \begin{bmatrix}\lambda_1 & 0 \\\\ 0&\lambda_2 \end{bmatrix} 当corner与坐标轴没有对齐时，经过旋转变换就可以将其转换到与坐标轴对齐的角度，而这种旋转操作可以使用矩阵的相似化来表示（其实是二次型的化简，可以使用合同变换，而旋转变换的矩阵是酉矩阵，转置即为矩阵的逆，所以也是相似变换）。也就是说，矩阵$M$相似于某个对角阵。 M = R^{-1}\Sigma R, \text{其中}\Sigma = \begin{bmatrix}\lambda_1&0\\\\0&\lambda_2\end{bmatrix}所以，可以根据下面这张图利用矩阵$M$的特征值来判定角点和边缘点。当两个特征值都较大时为角点；当某个分量近似为0而另一个分量较大时，可以判定为边缘点（因为某个方向的导数为0）；当两个特征值都近似为0时，说明是普通点（flat point）。（课件原图如此，空缺的问号处应分别为$\lambda_1$和$\lambda_2$）。 然而矩阵的特征值计算较为复杂，所以使用下面的方法进行近似计算。 \theta = \det(M)-\alpha\text{trace}(M)^2 = \lambda_1\lambda_2-\alpha(\lambda_1+\lambda_2)^2 为了减弱噪声的影响，常常使用gaussian窗函数。如下式所示： w(x,y) = \exp(-(x^2+y^2)/2\sigma^2)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CS131-边缘检测]]></title>
      <url>%2F2017%2F01%2F24%2Fcs131-edge-detection%2F</url>
      <content type="text"><![CDATA[边缘(Edge)在哺乳动物的视觉中有重要意义。在由若干卷积层构成的深度神经网络中，较低层的卷积层就被训练成为对特定形状的边缘做出响应。边缘检测也是计算机视觉和图像处理领域中一个重要的问题。 边缘的产生若仍采取将图像视作某一函数的观点，边缘是指这个函数中的不连续点。边缘检测是后续进行目标检测和形状识别的基础，也能够在立体视觉中恢复视角等。边缘的来源主要有以下几点： 物体表面不平造成灰度值的不连续； 深度值不同造成灰度值不连续； 物体表面颜色的突变造成灰度值不连续 朴素思想利用边缘是图像中不连续点的这一性质，可以通过计算图像的一阶导数，再找到一阶导数的极大值，即认为是边缘点。如下图所示，在白黑交界处，图像一阶导数的值非常大，表明此处灰度值变化剧烈，是边缘。 问题转换为如何求取图像的一阶导数（或梯度）。由于图像是离散的二元函数，所以下文不再区分求导与差分。 在$x$方向上，令$g_x = \frac{\partial f}{\partial x}$；在$y$方向上，令$g_y = \frac{\partial f}{\partial y}$。梯度的大小和方向为 g = \lbrack g_x, g_y\rbrack, \theta = \arctan(g_y/g_x)通过和Sobel算子等做卷积，可以求取两个正交方向上图像的一阶导数，并计算梯度，之后检测梯度的局部极大值就能够找出边缘点了。 只是这种方法很容易受到噪声影响。如图所示，真实的边缘点被湮没在了噪声中。 改进1：先平滑改进措施1，可以首先对图像进行高斯平滑，再按照上面的方法求取边缘点。根据卷积的性质，有： \frac{d}{dx}(f\ast g) = f\ast\frac{d}{dx}g所以我们可以先求取高斯核的一阶导数，再和原始图像直接做一次卷积就可以一举两得了。这样，引出了DoG(Deriative of Gaussian)。$x$方向的DoG如图所示。 进行高斯平滑不可避免会使图像中原本的细节部分模糊，所以需要在克服噪声和引入模糊之间做好折中。 改进2：Canny检测子改进措施2，使用Canny检测子进行检测。Canny检测方法同样基于梯度，其基本原理如下： 使用DoG计算梯度幅值和方向。 非极大值抑制，这个过程需要根据梯度方向做线性插值。如图，沿着点$q$的梯度方向找到了$p$和$r$两个点。这两个点的梯度幅值需要根据其临近的两点做插值得到。 利用梯度方向和边缘线互相垂直这一性质，如图，若已经确定点$p$为边缘点，则向它的梯度方向正交方向上寻找下一个边缘点（点$r$或$s$）。这一步也叫edge linking。 同时，为了提高算法性能，Canny中采用了迟滞阈值的方法，设定low和high两个阈值，来判定某个点是否属于强或弱边缘点。在做edge linking的时候，从强边缘点开始，如果遇到了弱边缘点，则继续，直到某点的梯度幅值甚至比low还要小，则在此停止。 改进3：RANSAC方法有的时候，我们并不是想要找到所有的边缘点，可能只是想找到图像中水平方向的某些边缘。这时候可以考虑采用RANSAC方法。 RANSAC方法的思想在于，认为已有的feature大部分都是好的。这样，每次随机抽取出若干feature，建立model，再在整个feature集合上进行验证。那么由那些好的feature得到的model一定是得分较高的。（世界上还是好人多啊！）这样就剔除了离群点的影响。 以直线拟合为例，在下图中，给出了使用RANSAC方法拟合直线的步骤。如图1所示，由于离群点的存在，如果直接使用最小二乘法进行拟合，拟合结果效果会很不理想。由于确定一条直线需要两个点，所以从点集中选取两个点，并计算拟合直线。并计算点集中的点在这条直线附近的个数，作为对模型好坏的判定，这些点是新的内点。找出最优的那条直线，使用其所有内点再进行拟合，重复上述操作，直至迭代终止。 上述RANSAC方法进行直线拟合的过程可以总结如下： 按照上述思想，我分别使用最小二乘法和RANSAC方法尝试进行直线拟合。在下面的代码中，我首先产生了正常受到一定高斯噪声污染的数据（图中的红色点），这些点的真值都落在直线$y = 2x+1$上。而后，我随机变化了斜率和截距，以期产生一些离群点（图中的蓝色点）。当然，由于随机性，这种方法生成的点有可能仍然是内点。 而后，我分别使用上述两种方法进行拟合。可以从结果图中看出，RANSAC（绿色线）能够有效避免离群点的干扰，获得更好的拟合效果。在某次实验中，两种方法的拟合结果如下：12least square: a = 3.319566, b = -1.446528ransac method: a = 1.899640, b= 1.298608 实验使用的MATLAB代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162%% generate datax = 0:1:10;y_gt = 2*x+1;y = y_gt + randn(size(y_gt));scatter(x, y, [], [1,0,0]);hold onout_x = 0:1:10;out_y = 5*rand(size(out_x)).*out_x + 4*rand(size(out_x));scatter(out_x, out_y, [], [0,0,1]);X = [x, out_x]';Y = [y, out_y]';X = [X, ones(length(X), 1)];[a, b] = ls_fit(X, Y);plot(x, a*x+b, 'linestyle', '--', 'color', 'r');[ra, rb] = ransac_fit(X, Y, 100, 2, 0.5, 3);plot(x, ra*x+rb, 'linestyle', '-.', 'color', 'g');fprintf('least square: a = %f, b = %f\n',a, b);fprintf('ransac method: a = %f, b= %f\n', ra, rb)function [a, b] = ransac_fit(X, Y, k, n, t ,d)% ransac fit% k -- maximum iteration number% n -- smallest point numer required% t -- threshold to identify a point is fit well% d -- the number of nearby points to assert a model is finedata = [X, Y];N = size(data, 1);best_good_cnt = -1;best_a = 0;best_b = 0;for i = 1:k % sample point idx = randsample(N, n); data_sampled = data(idx, :); % fit with least square [a, b] = ls_fit(data_sampled(:, 1:2), data_sampled(:, 3)); % test model not_sampled = ones(N, 1); not_sampled(idx) = 0; not_sampled_data = data(not_sampled == 1, :); distance = abs(not_sampled_data(:, 1:2) * [a; b] - not_sampled_data(:, 3)) / sqrt(a^2+1); inner_flag = distance &lt; t; good_cnt = sum(inner_flag); if good_cnt &gt;= d &amp;&amp; good_cnt &gt; best_good_cnt best_good_cnt = good_cnt; data_refine = data(find(inner_flag), :); [a, b] = ls_fit(data_refine(:, 1:2), data_refine(:, 3)); best_a = a; best_b = b; end fprintf('iteration %d, best_a = %f, best_b = %f\n', i, best_a, best_b);enda = best_a;b = best_b;endfunction [a, b] = ls_fit(X, Y)% least square fitA = X'*X\X'*Y;a = A(1);b = A(2);end 我们对RANSAC稍作分析，可以大概了解试验次数$k$的确定方法。 仍然使用上述直线拟合的例子。如果所有点中内点所占的比例为$\omega$，每次挑选$n$个点尝试（上述demo代码中取$n=2$）。那么每次挑选的两个点全部是内点的概率为$\omega^n$。当选取的$n$个点全部为内点时，视为有效实验。那么，重复$k$次实验，有效实验次数为0的概率为$(1-\omega^n)^k$。由于底数小于1，所以我们只需尽量增大$k$，就能够降低这种倒霉的概率。下图是不同$n$和$\omega$情况下为了使得实验成功的概率大于0.99所需的$k$的分布。 RANSAC方法的有点在于能够较为鲁棒地估计模型的参数，而且实现简单。缺点在于当离群点比例较大时，为保证实验成功所需的$k$值较大。这时候，可能Hough变换等基于投票的方法更适合用于图像中的直线检测问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CS131-线性滤波器和矩阵的SVD分解]]></title>
      <url>%2F2017%2F01%2F23%2Fcs131-filter-svd%2F</url>
      <content type="text"><![CDATA[数字图像可以看做$\mathbb{R}^2 \rightarrow \mathbb{R}^c$的映射，其中$c$是图像的channel数。使用信号与系统的角度来看，如果单独考察某个channel，可以将图像看做是二维离散系统。 卷积卷积的概念不再详述，利用不同的kernel与原始图像做卷积，就是对图像进行线性滤波的过程。卷积操作时，以某一个点为中心点，最终结果是这个点以及它的邻域点的线性组合，组合系数由kernel决定。一般kernel的大小取成奇数。如下图所示。（图片来自博客《图像卷积与滤波的一些知识点》） 在卷积操作时，常常需要对图像做padding，常用的padding方法有： zero padding，也就是填充0值。 edge replication，也就是复制边缘值进行填充。 mirror extension，也就是将图像看做是周期性的，相当于使用对侧像素值进行填充。 作业1调整图像灰度值为0到255计算相应的k和offset值即可。另外MATLAB中的uint8函数可以将结果削顶与截底为0到255之间。123scale_ratio = 255.0 / (max_val - min_val);offset = -min_val * scale_ratio;fixedimg = scale_ratio * dark + offset; SVD图像压缩使用SVD进行图像压缩，下图是将所有奇异值按照从大到小的顺序排列的大小示意图。可以看到，第一个奇异值比其他高出一个数量级。 MATLAB实现分别使用10，50， 100个分量进行图像压缩，如下图所示。可以看到，k=10时，已经能够复原出原图像的大致轮廓。当k更大时，更多细节被复原出来。 MATLAB代码如下：12345678910111213141516171819202122232425%% read imageim = imread('./flower.bmp');im_gray = double(rgb2gray(im));[u, s, v] = svd(im_gray);%% get sigular valuesigma = diag(s);top_k = sigma(1:10);figureplot(1:length(sigma), sigma, 'r-', 'marker', 's', 'markerfacecolor', 'g');figuresubplot(2, 2, 1);imshow(uint8(im_gray));title('flower.bmp')index = 2;for k = [10, 50, 100] uk = u(:, 1:k); sk = s(1:k, 1:k); vk = v(:, 1:k); im_rec = uk * sk * vk'; subplot(2, 2, index); index = index + 1; imshow(uint8(im_rec)); title(sprintf('k = %d', k));end 图像SVD压缩中的误差分析完全是个人随手推导，不严格的说明： 将矩阵分块。由SVD分解公式$\mathbf{U}\mathbf{\Sigma} \mathbf{V^\dagger} = \mathbf{A}$，把$\mathbf{U}$按列分块，$\mathbf{V^\dagger}$按行分块，有下式成立： \begin{bmatrix} u_1 & u_2 &\vdots &u_n \end{bmatrix} \begin{bmatrix} \sigma_1 & & & \\\\ & \sigma_2& & \\\\ & & \ddots& \\\\ & & &\sigma_m \end{bmatrix} \begin{bmatrix} v_1^\dagger\\\\ v_2^\dagger\\\\ \dots\\\\ v_m^\dagger \end{bmatrix}=\mathbf{A}由于 \begin{bmatrix} u_1 & u_2 &\vdots &u_n \end{bmatrix} \begin{bmatrix} \sigma_1 & & & \\\\ & \sigma_2& & \\\\ & & \ddots& \\\\ & & &\sigma_m \end{bmatrix} = \begin{bmatrix} \sigma_1u_1 & \sigma_2u_2 &\vdots &\sigma_nu_n \end{bmatrix}所以， \mathbf{A} = \sum_{i = 1}^{r}\sigma_iu_iv_i^\dagger上面的式子和式里面只有$r$项，是因为当$k &gt; r$时，$\sigma_k = 0$。 所以\mathbf{A} - \hat{\mathbf{A}} = \sum_{i = k+1}^{r}\sigma_iu_iv_i^\dagger 根绝矩阵范数的性质，我们有， \left\lVert\mathbf{A} - \hat{\mathbf{A}}\right\rVert \le \sum_{i=k+1}^{r}\sigma_i\left\lVert u_i\right\rVert\left\lVert v_i^\dagger\right\rVert由于$u_i$和$v_i$都是标准正交基，所以范数小于1.故， \left\lVert\mathbf{A} - \hat{\mathbf{A}}\right\rVert \le \sum_{i=k+1}^{r}\sigma_i取无穷范数，可以知道对于误差矩阵中的任意元素（也就是压缩重建之后任意位置的像素灰度值之差），都有： e \le \sum_{i=k+1}^{r}\sigma_iSVD与矩阵范数如果某个函数$f$满足以下的性质，就可以作为矩阵的范数。 $f(\mathbf{A}) = \mathbf{0} \Leftrightarrow \mathbf{A} = \mathbf{0}$ $f(c\mathbf{A}) = c f(\mathbf{A}), \forall c \in \mathbb{R}$ $f(\mathbf{A+b}) \le f(\mathbf{A}) + f(\mathbf{B})$ 其中，矩阵的2范数可以定义为 \left\lVert\mathbf{A}\right\rVert_2 = \max{\sqrt{(\mathbf{A}x)^\dagger\mathbf{A}x}}其中，$x$是单位向量。上式的意义在于表明矩阵的2范数是对于所有向量，经过该矩阵线性变换后摸长最大的那个变换后向量的长度。 下面，给出不严格的说明，证明矩阵的2范数数值上等于其最大的奇异值。 对于空间内的任意单位向量$x$，利用矩阵的SVD分解，有（为了书写简单，矩阵不再单独加粗）： (Ax)^\dagger Ax = x^\dagger V \Sigma^\dagger \Sigma V^\dagger x其中，$U^\dagger U = I$，已经被消去了。 进一步化简，我们将$V^\dagger x$看做一个整体，令$\omega = V\dagger x$，那么有， (Ax)^\dagger Ax = (\Sigma \omega)^\dagger \Sigma \omega也就是说，矩阵的2范转换为了$\Sigma \omega$的幅值的最大值。由于$\omega$是酉矩阵和一个单位向量的乘积，所以$\omega$仍然是单位阵。 由于$\Sigma$是对角阵，所以$\omega$与其相乘后，相当于每个分量分别被放大了$\sigma_i$倍。即 \Sigma \omega = \begin{bmatrix} \sigma_1 \omega_1\\\\ \sigma_2 \omega_2\\\\ \cdots\\\\ \sigma_n \omega_n \end{bmatrix}它的幅值平方为 \left\lVert \Sigma \omega \right \rVert ^2 = \sum_{i=1}^{n}\sigma_i^2 \omega_i^2 \le \sigma_{1} \sum_{i=1}^{n}\omega_i^2 = \sigma_1^2当且仅当，$\omega_1 = 1$, $\omega_k = 0, k &gt; 1$时取得等号。 综上所述，矩阵2范数的值等于其最大的奇异值。 矩阵的另一种范数定义方法Frobenius norm定义如下： \left\lVert A \right\rVert_{F} = \sqrt{\sum_{i=1}^{m}\sum_{j=1}^{n}\left\vert a_{i,j}\right\rvert}如果我们两边平方，可以得到，矩阵的F范数实际等于某个矩阵的迹，见下式： \left\lVert A\right \rVert_F^2 = \text{trace}(A^\dagger A)利用矩阵的SVD分解，可以很容易得出，$\text{trace}(A^\dagger A) = \sum_{i=1}^{r}\sigma_i^2$ 说明如下： \text{trace}(A^\dagger A) = \text{trace}(V\Sigma^\dagger\Sigma V^\dagger)由于$V^\dagger = V^{-1}$，而且$\text{trace}(BAB^{-1}) = \text{trace}(A)$，所以， \text{trace}(A^\dagger A) = \text{trace}(\Sigma^\dagger \Sigma) = \sum_{i=1}^{r}\sigma_i^2也就是说，矩阵的F范数等于它的奇异值平方和的平方根。 \left\lVert A\right\rVert_F= \sqrt{\sum_{i=1}^{r}\sigma_i^2}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CS131-线代基础]]></title>
      <url>%2F2017%2F01%2F22%2Fcs131-linear-alg%2F</url>
      <content type="text"><![CDATA[课程简介CS131课程(Computer Vision: Foundations and Applications)，是斯坦福大学Li Feifei实验室开设的一门计算机视觉入门基础课程，该课程目的在于为刚接触计算机视觉领域的学生提供基本原理和应用介绍。目前2016年冬季课程刚刚结束。CS131博客系列主要是关于本课的slide知识点总结与作业重点问题归纳，作为个人学习本门课程的心得体会和复习材料。 由于是个人项目，所以会比较随意，只对个人感兴趣的内容做一总结。这篇文章是对课前的线代基础做一复习与整理。 向量与矩阵数字图像可以看做二维矩阵，向量是特殊的矩阵，本课程默认的向量都是列向量。slide中给出了一些矩阵行列式和迹的性质，都比较简单，这里不再多说。 矩阵作为线性变换通过线代知识，我们知道，在线性空间中，如果给定一组基，线性变换可以通过对应的矩阵来进行描述。 scale变换对角阵可以用来表示放缩变换。 \begin{bmatrix} s_x & 0\\\\ 0 & s_y \end{bmatrix}\begin{bmatrix} x\\\\ y \end{bmatrix} = \begin{bmatrix} s_xx\\\\ s_yy \end{bmatrix}旋转变换如图所示，逆时针旋转$theta$角度，对应的旋转矩阵为： \mathbf{R} = \begin{bmatrix} \cos\theta &-\sin\theta \\\\ \sin\theta &\cos\theta \end{bmatrix}旋转矩阵是酉矩阵，矩阵内的各列（或者各行）相互正交。满足如下的关系式： \mathbf{R}\mathbf{R^{\dagger}} = \mathbf{I}由于$\det{\mathbf{R}} = \det{\mathbf{R^{\dagger}}}$，所以，对于酉矩阵，$\det{\mathbf{R}} = \pm 1$旋转矩阵是酉矩阵，矩阵内的各列（或者各行）相互正交。满足如下的关系式： \mathbf{R}\mathbf{R^{\dagger}} = \mathbf{I}由于$\det{\mathbf{R}} = \det{\mathbf{R^{\dagger}}}$，所以，对于酉矩阵，$\det{\mathbf{R}} = \pm 1$. 齐次变换(Homogeneous Transform)只用上面的二维矩阵不能表达平移，使用齐次矩阵可以表达放缩，旋转和平移操作。 \mathbf{H} =\begin{bmatrix} a & b & t_x\\\\ c & d & t_y\\\\ 0 & 0 & 1 \end{bmatrix},\mathbf{H}\begin{bmatrix} x\\\\ y\\\\ 1\\\\ \end{bmatrix}=\begin{bmatrix} ax+by+t_x\\\\ cx+dy+t_y\\\\ 1 \end{bmatrix}SVD分解可以将矩阵分成若干个矩阵的乘积，叫做矩阵分解，比如QR分解，满秩分解等。SVD分解，即奇异值分解，也是一种特殊的矩阵分解方法。如下式所示，是将矩阵分解成为三个矩阵的乘积： \mathbf{U}\mathbf{\Sigma}\mathbf{V^\dagger} = \mathbf{A}其中矩阵$\mathbf{A}$大小为$m\times n$，矩阵$\mathbf{U}$是大小为$m\times m$的酉矩阵，$\mathbf{V}$是大小为$n \times n$的酉矩阵，$\mathbf{\Sigma}$是大小为$m \times n$的旋转矩阵，即只有主对角元素不为0. SVD分解在主成分分析中年很有用。由于矩阵$\mathbf{\Sigma}$一般情况下是将奇异值按照从大到小的顺序摆放，所以矩阵$\mathbf{U}$中，前面的若干列被视作主成分，后面的列显得相对不这么重要。可以抛弃后面的列，进行图像压缩。 如下图，是使用前10个分量对原图片进行压缩的效果。 12345678910im = imread('./superman.png');im_gray = rbg2gray(im);[u, s, v] = svd(double(im_gray));k = 10;uk = u(:, 1:k);sigma = diag(s);sk = diag(sigma(1:k));vk = v(:, 1:k);im_k = uk*sk*vk';imshow(uint8(im_k))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Visual Studio 编译 GSL 科学计算库]]></title>
      <url>%2F2016%2F12%2F16%2Fgsl-with-vs%2F</url>
      <content type="text"><![CDATA[GSL是一个GNU支持的科学计算库，提供了很丰富的数值计算方法。GSL 的项目主页提供的说明来看，它支持如下的科学计算： （下面的这张表格的HTML使用的是No-Cruft Excel to HTML Table Converter生成的） Complex Numbers Roots of Polynomials Special Functions Vectors and Matrices Permutations Sorting BLAS Support Linear Algebra Eigensystems Fast Fourier Transforms Quadrature Random Numbers Quasi-Random Sequences Random Distributions Statistics Histograms N-Tuples Monte Carlo Integration Simulated Annealing Differential Equations Interpolation Numerical Differentiation Chebyshev Approximation Series Acceleration Discrete Hankel Transforms Root-Finding Minimization Least-Squares Fitting Physical Constants IEEE Floating-Point Discrete Wavelet Transforms Basis splines GSL的Linux下的配置很简单，照着它的INSTALL文件一步一步来就可以了。CMAKE大法HAO! 1234./configuremakemake installmake clean 同样的，GSL也可以在Windows环境下配置，下面记录了如何在Windows环境下使用 Visual Studio 和 CMakeGUI 编译测试GSL。 使用CMAKE编译成.SLN文件打开CMAKEGUI，将输入代码路径选为GSL源代码地址，输出路径设为自己想要的输出路径。点击 “Configure“，选择Visual Studio2013为编译器，点击Finish后会进行必要的配置。然后将表格里面的选项都打上勾，再次点击”Configure“，等待完成之后点击”Generate“。完成之后，就可以在输出路径下看到GSL.sln文件了。 使用Visual Studio生成解决方案使用 Visual Studio 打开刚才生成的.SLN文件，分别在Debug和Release模式下生成解决方案，等待完成即可。 当完成后，你应该可以在路径下看到这样一张图，我们主要关注的文件夹是\bin，\gsl，\Debug和\Release。 加入环境变量修改环境变量的Path，将\GSL_Build_Path\bin\Debug加入，这主要是为了\Debug文件夹下面的gsl.dll文件。如果不进行这一步的话，一会虽然可以编译，但是却不能运行。 这里顺便注释一句，当使用第三方库的时候，如果需要动态链接库的支持，其中一种方法就是将DLL文件的路径加入到Path中去。 建立Visual Studio属性表Visual Studio可以通过建立工程属性表的方法来配置工程选项，一个OpenCV的例子可以参见Yuanbo She的这篇博文 Opencv 完美配置攻略 2014 (Win8.1 + Opencv 2.4.8 + VS 2013)。 配置文件中主要是包含文件和静态链接库LIB的路径设置。下面把我的贴出来，只需要根据GSL的生成路径做相应修改即可。注意我的属性表中保留了OpenCV的内容，如果不需要的话，尽可以删掉。上面的博文对这张属性表如何配置讲得很清楚，有问题可以去参考。 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt; &lt;ImportGroup Label="PropertySheets" /&gt; &lt;PropertyGroup Label="UserMacros" /&gt; &lt;PropertyGroup&gt; &lt;IncludePath&gt;$(OPENCV249)\include;E:\GSLCode\gsl-build\;$(IncludePath)&lt;/IncludePath&gt; &lt;LibraryPath Condition="'$(Platform)'=='Win32'"&gt;$(OPENCV249)\x86\vc12\lib;E:\GSLCode\gsl-build\Debug;$(LibraryPath)&lt;/LibraryPath&gt; &lt;LibraryPath Condition="'$(Platform)'=='X64'"&gt;$(OPENCV249)\x64\vc12\lib;E:\GSLCode\gsl-build\Debug;$(LibraryPath)&lt;/LibraryPath&gt; &lt;/PropertyGroup&gt; &lt;ItemDefinitionGroup&gt; &lt;Link Condition="'$(Configuration)'=='Debug'"&gt; &lt;AdditionalDependencies&gt;opencv_calib3d249d.lib;opencv_contrib249d.lib;opencv_core249d.lib;opencv_features2d249d.lib;opencv_flann249d.lib;opencv_gpu249d.lib;opencv_highgui249d.lib;opencv_imgproc249d.lib;opencv_legacy249d.lib;opencv_ml249d.lib;opencv_nonfree249d.lib;opencv_objdetect249d.lib;opencv_ocl249d.lib;opencv_photo249d.lib;opencv_stitching249d.lib;opencv_superres249d.lib;opencv_ts249d.lib;opencv_video249d.lib;opencv_videostab249d.lib;gsl.lib;gslcblas.lib;%(AdditionalDependencies)&lt;/AdditionalDependencies&gt; &lt;/Link&gt; &lt;Link Condition="'$(Configuration)'=='Release'"&gt; &lt;AdditionalDependencies&gt;opencv_calib3d249.lib;opencv_contrib249.lib;opencv_core249.lib;opencv_features2d249.lib;opencv_flann249.lib;opencv_gpu249.lib;opencv_highgui249.lib;opencv_imgproc249.lib;opencv_legacy249.lib;opencv_ml249.lib;opencv_nonfree249.lib;opencv_objdetect249.lib;opencv_ocl249.lib;opencv_photo249.lib;opencv_stitching249.lib;opencv_superres249.lib;opencv_ts249.lib;opencv_video249.lib;opencv_videostab249.lib;gsl.lib;gslcblas.lib;%(AdditionalDependencies)&lt;/AdditionalDependencies&gt; &lt;/Link&gt; &lt;/ItemDefinitionGroup&gt; &lt;ItemGroup /&gt;&lt;/Project&gt; 在以后建立Visual Studio工程的时候，在属性窗口直接添加现有属性表就可以了！ 测试在项目网站的教程上直接找到一段代码，进行测试，输出贝塞尔函数的值。 123456789#include &lt;stdio.h&gt;#include &lt;gsl/gsl_sf_bessel.h&gt;int main(void)&#123; double x = 5.0; double y = gsl_sf_bessel_J0(x); printf("J0(%g) = %.18e\n", x, y); return 0;&#125; 控制台输出正确：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F16%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Code highlightHello World! 1234#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; "HelloWorld\n";&#125; 1print 'HelloWorld' Latex Support by MathjaxMass-energy equation by Einstein: $E = mc^2$ a linear equation: $$\mathbf{A}\mathbf{v} = \mathbf{y}$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows环境下使用Doxygen生成注释文档]]></title>
      <url>%2F2016%2F12%2F16%2Fuse-doxygen%2F</url>
      <content type="text"><![CDATA[Doxygen 是一种很好用的代码注释生成工具，然而和很多国外的工具软件一样，在中文环境下，它的使用总是会出现一些问题，也就是中文注释文档出现乱码。经过调试，终于是解决了这个问题。 安装 DoxygenDoxygen 在Windows平台下的安装是简单的，Doxygen的项目主页提供了下载和安装的使用说明，可以下载它们的官方使用手册进行阅读。对于Windows，提供了源代码编译安装和直接安装程序安装两种方式，可以自行选择。 安装成功后，使用命令行命令 1doxygen --help 就可以查看帮助文档，对应参数含义一目了然，降低了入手难度。 使用命令， 1doxygen -g doxygen_filename 就可以在当前目录下建立一个doxygen配置文件，用文本编辑器打开就可以编辑里面的配置选项。 使用命令， 1doxygen doxygen_filename 就可以生成注释文档了。 下面就来说一说对中文的支持。 生成 HTML 格式文档中文之所以乱码，很多时候是由于编码和译码格式不同，所以我们需要先知道自己代码文件的编码方式。我的代码都是建立在Visual Studio上的，可以通过VS的高级保存选项查看自己代码文件的存储编码格式。对于中文版的VS，一般应该是GB2312。 我们打开 Doxygen 的配置文件，将里面的 INPUT_ENCODING 改为我们代码文件的编码格式，这里就改成 GB2312。 这样一来，编译出来的 HTML 页面就不会有中文乱码了。 生成Latex 格式文档生成 Latex 需要本机上安装有 Latex 的编译环境。如果是中文用户，推荐的是CTEX套件，可以到他们的网站上去下载。 可以看到，Doxygen为Latex文件的编译生成了make文件，我们在命令行窗口中执行make命令就可以完成编译，然而这时候会发现编译出错，pdf文档无法生成。 打开生成的refman.latex文档，添加宏包 CJKutf8。然后找到 \begin{document}一行，将其改为 12\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gbsn&#125; 也就是说为正文提供了CJK环境，这样中文文本就可以正常编译了。 相应的，我们要将结尾的 \end{document)改为：12\end&#123;CJK&#125; \end&#123;document&#125; 这样，运行make命令之后，就可以看到中文的注释文档了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Regular Expressions （Python 正则表达式)]]></title>
      <url>%2F2014%2F07%2F17%2Fpython-reg-exp%2F</url>
      <content type="text"><![CDATA[本文来自于Google Developers中对于Python的介绍。https://developers.google.com/edu/python/regular-expressions。 认识正则表达式Python的正则表达式是使用 re 模块的。 12345match = re.search(pattern,str)if match: print 'found',match.group()else: print 'NOT Found!' 正则表达式的规则基本规则 a, x, 9 都是普通字符 (ordinary characters) . (一个点)可以匹配任何单个字符（除了’\n’） \w（小写的w）可以匹配一个单词里面的字母，数字或下划线 [a-zA-Z0-9_];\W （大写的W）可以匹配非单词里的这些元素 \b 匹配单词与非单词的分界 \s（小写的s）匹配一个 whitespace character，包括 space，newline，return，tab，form(\n\r\t\f)；\S（大写的S）匹配一个非 whitespace character \d 匹配十进制数字 [0-9] ^=start，$=end 用来匹配字符串的开始和结束 \ 是转义字符，用 . 来匹配串里的’.’，等一些基本的例子 12345678910## 在字符串'piiig'中查找'iii'match = re.search(r'iii', 'piiig') # found, match.group() == "iii"match = re.search(r'igs', 'piiig') # not found, match == None## . 匹配除了\n的任意字符match = re.search(r'..g', 'piiig') # found, match.group() == "iig"## \d 匹配0-9的数字字符, \w 匹配单词里的字符match = re.search(r'\d\d\d', 'p123g') # found, match.group() == "123"match = re.search(r'\w\w\w', '@@abcd!!') # found, match.group() == "abc" 重复可以用’+’ ‘*’ ‘?’来匹配0个，1个或多个重复字符。 ‘+’ 用来匹配1个或者多个字符 ‘*’ 用来匹配0个或者多个字符 ‘?’ 用来匹配0个或1个字符 注意，’+’和’*’会匹配尽可能多的字符。 一些重复字符的例子12345678910111213141516## i+ 匹配1个或者多个'i'match = re.search(r'pi+', 'piiig') # found, match.group() == "piii"## 找到字符串中最左边尽可能长的模式。## 注意，并没有匹配到第二个 'i+'match = re.search(r'i+', 'piigiiii') # found, match.group() == "ii"## \s* 匹配0个或1个空白字符 whitespacematch = re.search(r'\d\s*\d\s*\d', 'xx1 2 3xx') # found, match.group() == "1 2 3"match = re.search(r'\d\s*\d\s*\d', 'xx12 3xx') # found, match.group() == "12 3"match = re.search(r'\d\s*\d\s*\d', 'xx123xx') # found, match.group() == "123"## ^ 匹配字符串的第一个字符match = re.search(r'^b\w+', 'foobar') # not found, match == None## 与上例对比match = re.search(r'b\w+', 'foobar') # found, match.group() == "bar" Email考虑一个典型的Email地址：someone@host.com，可以用如下的方式匹配： 12345678910 match = re.search(r'\w+@\w+',str)``` 但是，对于这种Email地址 'xyz alice-b@google.com purple monkey' 则不能奏效。### 使用方括号 ###方括号里面的字符表示一个字符集合。[abc]可以被用来匹配'a'或者'b'或者'c'。\w \s等都可以用在方括号里，除了'.'以外，它只能用来表示字面意义上的‘点’。所以上面的Email规则可以扩充如下： ``` py match = re.search('r[\w.-]+@[\w.-]+',str) 你还可以使用’-‘来指定范围，如[a-z]指示的是所有小写字母的集合。所以如果你想构造的字符集合中有’-‘，请把它放到末尾[ab-]。另外，前方加上’^’，用来表示取集合的补集，例如ab表示除了’a’和’b’之外的其他字符。 操作以Email地址为例，如果我们想要分别提取该地址的用户名’someone’和主机名’host.com’该怎么办呢？可以在模式中用圆括号指定。 123456str = 'purple alice-b@google.com monkey dishwasher'match = re.search('([\w.-]+)@([\w.-]+)', str) #用圆括号指定分割if match: print match.group() ## 'alice-b@google.com' (the whole match) print match.group(1) ## 'alice-b' (the username, group 1) print match.group(2) ## 'google.com' (the host, group 2) findall 函数与group函数只找到最左端的一个匹配不同，findall函数找到字符串中所有与模式匹配的串。 12345str = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'## findall返回一个包含所有匹配结果的 listemails = re.findall(r'[\w\.-]+@[\w\.-]+', str) ## ['alice@google.com', 'bob@abc.com']for email in emails: print email 在文件中使用findall当然可以读入文件的每一行，然后对每一行的内容调用findall，但是为什么不让这一切自动发生呢？ 12f = open(filename.txt,'r')matches = re.findall(pattern,f.read()) findall 和分组和group的用法相似，也可以指定分组。 12345678str = 'purple alice@google.com, blah monkey bob@abc.com blah dishwasher'## 返回了一个listtuples = re.findall(r'([\w\.-]+)@([\w\.-]+)', str)print tuples ## [('alice', 'google.com'), ('bob', 'abc.com')]## list中的元素是tuple for tuple in tuples: print tuple[0] ## username print tuple[1] ## host 调试正则表达式异常强大，使用简单的几条规则就可以演变出很多的模式组合。在确定你的模式之前，可能需要很多的调试工作。在一个小的测试集合上测试正则表达式。 其他选项正则表达式还可以设置“选项”。 1match = re.search(pat,str,opt) 这些可选项如下： IGNORECASE 忽视大小写 DOTALL 允许’.’匹配’\n’ MULTILINE 在一个由许多行组成的字符串中，允许’^’和’$’匹配每一行的开始和结束]]></content>
    </entry>

    
  
  
</search>
